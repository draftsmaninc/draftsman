<?php

namespace Draftsman\Draftsman\Actions;

use Illuminate\Http\Request;
use Illuminate\Support\Arr;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\File;

class UpdateDraftsmanConfig
{
    /**
     * Handle updating the Draftsman config and, conditionally, the .env file.
     *
     * Rules:
     * - Ensure config/draftsman.php exists (publish if missing).
     * - Merge vendor defaults with incoming payload (payload overrides).
     * - Write merged config to config/draftsman.php.
     * - If update_env (from merged config) is true, update only existing
     *   DRAFTSMAN_* keys in .env. Never append new keys.
     * - Always run config:clear after writing config and any env updates.
     *
     * @param array $payload JSON body decoded to array
     * @return array{message:string, config:array, env_updated:bool}
     */
    public function handle(array $payload): array
    {
        $publishedConfigPath = base_path('config/draftsman.php');
        $vendorConfigPath = base_path('vendor/draftsmaninc/draftsman/config/draftsman.php');

        // Ensure published config exists
        if (! File::exists($publishedConfigPath)) {
            Artisan::call('vendor:publish', ['--tag' => 'draftsman-config']);
        }

        // Load defaults from vendor
        $defaults = [];
        if (File::exists($vendorConfigPath)) {
            $defaults = include $vendorConfigPath;
            if (! is_array($defaults)) {
                $defaults = [];
            }
        }

        // Merge defaults with incoming payload (payload overwrites)
        $merged = $this->arrayMergeRecursiveDistinct($defaults, $payload);

        // Write merged config
        $this->writePhpConfig($publishedConfigPath, $merged);

        $didWriteEnv = false;
        $updateEnvFlag = (bool) Arr::get($merged, 'config.update_env', Arr::get($merged, 'update_env', false));
        if ($updateEnvFlag === true) {
            $envUpdates = $this->buildEnvMapFromConfig($merged);
            if (count($envUpdates)) {
                $this->updateEnvFile($envUpdates);
                $didWriteEnv = true;
            }
        }

        // Always clear config when writing
        Artisan::call('config:clear');

        return [
            'message' => 'Draftsman configuration updated successfully.',
            'config' => $merged,
            'env_updated' => $didWriteEnv,
        ];
    }

    private function arrayMergeRecursiveDistinct(array $base, array $override): array
    {
        foreach ($override as $key => $value) {
            if (is_array($value) && isset($base[$key]) && is_array($base[$key])) {
                $base[$key] = $this->arrayMergeRecursiveDistinct($base[$key], $value);
            } else {
                $base[$key] = $value;
            }
        }

        return $base;
    }

    private function writePhpConfig(string $path, array $config): void
    {
        $export = var_export($config, true);
        $contents = <<<PHP
<?php

// This file is auto-generated by Draftsman API. Do not edit manually.

return {$export};

PHP;
        File::ensureDirectoryExists(dirname($path));
        File::put($path, $contents);
    }

    private function buildEnvMapFromConfig(array $config): array
    {
        $map = [];

        $addSection = function (string $section, array $values) use (&$map) {
            $iterator = function ($arr, $prefix = '') use (&$map, $section, & $iterator) {
                foreach ($arr as $k => $v) {
                    $keyPart = strtoupper(is_int($k) ? (string) $k : str_replace(['-', '.'], '_', $k));
                    $currentPrefix = $prefix === '' ? $keyPart : $prefix . '_' . $keyPart;
                    if (is_array($v)) {
                        $iterator($v, $currentPrefix);
                    } else {
                        if ($section === 'config') {
                            $envKey = 'DRAFTSMAN_' . $currentPrefix;
                        } else {
                            $envKey = 'DRAFTSMAN_' . strtoupper($section) . '_' . $currentPrefix;
                        }
                        $map[$envKey] = $this->scalarToEnv($v);
                    }
                }
            };
            $iterator($values);
        };

        foreach ($config as $section => $values) {
            if (! is_array($values)) {
                $map['DRAFTSMAN_' . strtoupper($section)] = $this->scalarToEnv($values);
                continue;
            }
            $addSection($section, $values);
        }

        return $map;
    }

    private function scalarToEnv($value): string
    {
        if (is_bool($value)) {
            return $value ? 'true' : 'false';
        }
        if ($value === null) {
            return 'null';
        }
        return (string) $value;
    }

    private function updateEnvFile(array $updates): void
    {
        $envPath = base_path('.env');
        $lines = File::exists($envPath) ? preg_split("/\r?\n/", File::get($envPath)) : [];
        $existingKeys = [];
        foreach ($lines as $idx => $line) {
            if (preg_match('/^([A-Z0-9_]+)\s*=.*/', $line, $m)) {
                $existingKeys[$m[1]] = $idx;
            }
        }

        foreach ($updates as $k => $v) {
            // Only update keys that start with DRAFTSMAN_
            if (strpos($k, 'DRAFTSMAN_') !== 0) {
                continue;
            }
            // Update only if key already exists; do not append missing keys
            if (array_key_exists($k, $existingKeys)) {
                $entry = $k . '=' . $this->quoteEnvValue($v);
                $lines[$existingKeys[$k]] = $entry;
            }
        }

        File::put($envPath, implode(PHP_EOL, $lines) . PHP_EOL);
    }

    private function quoteEnvValue(string $value): string
    {
        if (preg_match('/\s|#|\\"|\\' . "'" . '/u', $value)) {
            $escaped = str_replace('"', '\\"', $value);
            return '"' . $escaped . '"';
        }
        return $value;
    }
}
